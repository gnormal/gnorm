// Code generated by gnorm, DO NOT EDIT!

package statistics

import (
	"gnorm.org/gnorm/database/drivers/sqlite/gnorm"
	"log"
	"strings"
)

// Row represents a row from 'STATISTICS'.
type Row struct {
	Unique     bool   // NON_UNIQUE
	IndexName  string // INDEX_NAME
	SeqInIndex int64  // SEQ_IN_INDEX
	Origin     string // SEQ_IN_INDEX
	Partial    int64  // SEQ_IN_INDEX
}

type RowColumns struct {
	SeqNo int
	Cid   int
	Name  string
	Desc  string
	Coll  string
	Key   int
}

// Query retrieves rows from 'STATISTICS' as a slice of Row.
func Query(db gnorm.DB, table string) ([]*Row, error) {
	const sqlstr = `
		 SELECT seq, 
                name, 
                "unique", 
                origin, 
                "partial" 
           FROM pragma_index_list('XXXTABLEXXX')
;
`
	sql := strings.Replace(sqlstr, "XXXTABLEXXX", table, -1)
	log.Println("querying indices ", sql)
	log.Println("from table ", table)

	var vals []*Row
	q, err := db.Query(sql)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}

		err = q.Scan(
			&r.SeqInIndex,
			&r.IndexName,
			&r.Unique,
			&r.Origin,
			&r.Partial,
		)

		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}

// Query retrieves rows from 'STATISTICS' as a slice of Row.
func QueryIndex(db gnorm.DB, index string) ([]*RowColumns, error) {

	const sqlstr = `
		 SELECT seqno, 
                cid, 
                name,
                desc, 
                coll, 
                key
           FROM pragma_index_xinfo('XXXINDEXXXX') 
          WHERE key = 1
;
`
	sql := strings.Replace(sqlstr, "XXXINDEXXXX", index, -1)
	log.Println("querying index info ", sql)
	log.Println("from index ", index)

	var vals []*RowColumns
	q, err := db.Query(sql)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := RowColumns{}

		err = q.Scan(
			&r.SeqNo,
			&r.Cid,
			&r.Name,
			&r.Desc,
			&r.Coll,
			&r.Key,
		)

		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}

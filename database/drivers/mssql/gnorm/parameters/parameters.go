// Code generated by gnorm, DO NOT EDIT!

package parameters

import (
	"database/sql"
	"gnorm.org/gnorm/database/drivers/mssql/gnorm"
	"log"
)

// Row represents a row from 'COLUMNS'.
type Row struct {
	ProcCatalog            string         // PROC_CATALOG
	ProcSchema             string         // PROC_SCHEMA
	ProcName               string         // PROC_NAME
	ParameterName          string         // PARAMETER_NAME
	OrdinalPosition        int            // ORDINAL_POSITION
	ParameterDefault       sql.NullString // PARAMETER_DEFAULT
	IsNullable             string         // IS_NULLABLE
	DataType               string         // DATA_TYPE
	NumericPrecision       sql.NullInt64  // NUMERIC_PRECISION
	NumericPrecisionRadix  sql.NullInt64  // NUMERIC_PRECISION_RADIX
	NumericScale           sql.NullInt64  // NUMERIC_SCALE
	DatetimePrecision      sql.NullInt64  // DATETIME_PRECISION
	CharacterMaximumLength sql.NullInt64  // CHARACTER_MAXIMUM_LENGTH
	CharacterSetCatalog    sql.NullString // CHARACTER_SET_CATALOG
	CharacterSetSchema     sql.NullString // CHARACTER_SET_SCHEMA
	CharacterSetName       sql.NullString // CHARACTER_SET_NAME
	CollationCatalog       sql.NullString // COLLATION_CATALOG
	CollationSchema        sql.NullString // COLLATION_SCHEMA
	CollationName          sql.NullString // COLLATION_NAME
	DomainCatalog          sql.NullString // DOMAIN_CATALOG
	DomainSchema           sql.NullString // DOMAIN_SCHEMA
	DomainName             sql.NullString // DOMAIN_NAME
}

// Query retrieves rows from 'COLUMNS' as a slice of Row.
func Query(db gnorm.DB, schema string, proc string) ([]*Row, error) {
	const strsql = `

SELECT c.TABLE_CATALOG,
       c.TABLE_SCHEMA,
	   c.TABLE_NAME,
	   c.COLUMN_NAME,
	   c.ORDINAL_POSITION,
	   c.COLUMN_DEFAULT,
	   c.IS_NULLABLE,
	   c.DATA_TYPE,
	   c.NUMERIC_PRECISION,
	   c.NUMERIC_PRECISION_RADIX, 
	   c.NUMERIC_SCALE, 
	   c.DATETIME_PRECISION, 
	   c.CHARACTER_MAXIMUM_LENGTH,
	   c.CHARACTER_SET_CATALOG,
	   c.CHARACTER_SET_SCHEMA,
	   c.CHARACTER_SET_NAME,
	   c.COLLATION_CATALOG,
	   c.COLLATION_SCHEMA,
	   c.COLLATION_NAME,
	   c.DOMAIN_CATALOG,
	   c.DOMAIN_SCHEMA,
	   c.DOMAIN_NAME

  FROM INFORMATION_SCHEMA.COLUMNS c

  WHERE TABLE_SCHEMA = @schema
       AND TABLE_NAME = @proc
  ;
`
	log.Println("querying columns ", strsql)
	log.Println("from schema ", schema)
	log.Println("from proc ", proc)

	var vals []*Row
	q, err := db.Query(strsql,
		sql.Named("schema", schema),
		sql.Named("proc", proc),
	)

	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}

		err = q.Scan(
			&r.ProcCatalog,
			&r.ProcSchema,
			&r.ProcName,
			&r.ParameterName,
			&r.OrdinalPosition,
			&r.ParameterDefault,
			&r.IsNullable,
			&r.DataType,
			&r.NumericPrecision,
			&r.NumericPrecisionRadix,
			&r.NumericScale,
			&r.DatetimePrecision,
			&r.CharacterMaximumLength,
			&r.CharacterSetCatalog,
			&r.CharacterSetSchema,
			&r.CharacterSetName,
			&r.CollationCatalog,
			&r.CollationSchema,
			&r.CollationName,
			&r.DomainCatalog,
			&r.DomainSchema,
			&r.DomainName,
		)
		if err != nil {
			return nil, err
		}

		vals = append(vals, &r)
	}
	return vals, nil
}
